######################

#Find out if the hidden service SSP Job Control Service is started

(Get-SPFarm).Servers[“<servername>”].ServiceInstances | where {$_.typename –eq “SSP Job Control Service”}

######################

#Finding properties and methods using get-member

(Get-SPFarm).Servers[“<servername>”].ServiceInstances | where {$_.typename –eq “SSP Job Control Service”} | gm

######################

#Instantiating the SSP Job Controls service and starting it

$svc = (Get-SPFarm).Servers[“<servername>”].ServiceInstances | where {$_.typename –eq “SSP Job Control Service”}
$svc.provision()

######################

#Set logging back to normal

clear-SPLogLevel

######################

#Finding an endpoint for a service application

Get-SPServiceApplicationProxy | ? {$_.typename –like “search*”} | ft name, serviceendpointuri –wrap

######################

#Find the service application pool associated with a service application

Get-SPServiceApplication | ? {$_.typename –like “search*”} | ft name, applicationPool –wrap

######################

#Verify application pool, full circle

Get-SPServiceApplicationPool | ? {$_.name -like "*search*"} | ft name, id

######################

#Cross referencing what you found in iis to the search service application object model, and find the wsdl

$ssa = Get-SPEnterpriseSearchServiceApplication
Foreach ($pt in $ssa.endpoints) {$pt.ListenUris.AbsoluteUri}

######################

#Command line to find TCP Chimney and Task Offload settings

Netsh int tcp show global  | findstr Chimney
Netsh int tcp show global | findstr “Task Offload”

######################

#Set TCP Chimney to disabled if not already disabled

Netsh int tcp set global chimney=disabled


######################

#Finding out about the crawler status

SELECT
	hist.CrawlId, hist.CrawlType, hist.ContentSourceId, hist.StartTime, hist.Status, hist.SubStatus, hist.Request, ccState.ComponentID, ccState.Status as ccStatus, ccState.SuspendedCount
FROM [SEARCHDBNAME].[dbo][MSSCrawlHistory] AS hist WITH (nolock)
INNER JOIN
	[SEARCHDBNAME].[dbo].[MSSCrawlComponentsState] AS ccState
	ON hist.CrawlId = ccState.CrawlID
WHERE hist.Status Not In (5,11,12)
And hist.crawlId > 2

######################

#Crawl history in powerGrid 

$numberOfResults = 1000
$contentSourceName = "Local SharePoint Sites"
 
[System.Reflection.Assembly]::LoadWithPartialName("Microsoft.Office.Server.Search.Administration")
 
$searchServiceApplication = Get-SPEnterpriseSearchServiceApplication
$contentSources = Get-SPEnterpriseSearchCrawlContentSource -SearchApplication $searchServiceApplication
$contentSource = $contentSources | ? { $_.Name -eq $contentSourceName }
 
$crawlLog = new-object Microsoft.Office.Server.Search.Administration.CrawlLog($searchServiceApplication)
$crawlHistory = $crawlLog.GetCrawlHistory($numberOfResults, $contentSource.Id)
$crawlHistory.Columns.Add("CrawlTypeName", [String]::Empty.GetType()) | Out-Null
 
# Label the crawl type
$labeledCrawlHistory = $crawlHistory | % {
$_.CrawlTypeName = [Microsoft.Office.Server.Search.Administration.CrawlType]::Parse([Microsoft.Office.Server.Search.Administration.CrawlType], $_.CrawlType).ToString()
return $_
}
 
$labeledCrawlHistory | Out-GridView

######################

#how big is a content database

(get-spcontentdatabase <name of database>).disksizerequired

######################

#Site collection usage in MB

$site = get-spsite <URL to site>
$site.usage.storage / 1MB

######################

#Changing the continuous crawl interval from default to 5 minute intervals

(Get-SPEnterpriseSearchSrviceApplication).SetProperty("ContinuousCrawlInterval",<TimeInMinutes>)
# e.g.

(Get-SPEnterpriseSearchSrviceApplication).SetProperty("ContinuousCrawlInterval",5)

######################

#Find search performance level

Get-SPEnterpriseSearchService

######################

#Find the search topology

$ssa = Get-SPServiceApplication –Name "Search Service Application" 
$active = Get-SPEnterpriseSearchTopology -SearchApplication $ssa -Active
Get-SPEnterpriseSearchComponent -SearchTopology $active

######################

#Search Topology report format

$ssa = Get-SPServiceApplication –Name "Search Service Application" 
get-spenterprisesearchstatus -SearchApplication $ssa -Detailed -Text

######################

#Changing Search Topology

# Load SharePoint Admin Shell
Add-PSSnapin Microsoft.SharePoint.PowerShell -EA 0

 # Start the search service instance on every server that will be part of the new topology
$HOSTA = GET-SPENTERPRISESEARCHSERVICEINSTANCE -IDENTITY "sfawley-2013"
$HOSTB = GET-SPENTERPRISESEARCHSERVICEINSTANCE -IDENTITY "sfawley-2013-ap" 
START-SPENTERPRISESEARCHSERVICEINSTANCE -IDENTITY $HOSTA
START-SPENTERPRISESEARCHSERVICEINSTANCE -IDENTITY $HOSTB
 
#Wait until all servers show that the service is online by running a 
GET-SPENTERPRISESEARCHSERVICEINSTANCE -IDENTITY "<servername>"
 
$host1 = "sfawley-2013"
$host2 = "sfawley-2013-ap"
 
 # Create a new empty search topology
$SSA = GET-SPENTERPRISESEARCHSERVICEAPPLICATION
$Clone = NEW-SPENTERPRISESEARCHTOPOLOGY -SEARCHAPPLICATION $SSA
 
 # Add the new components
New-SPEnterpriseSearchAdminComponent –SearchTopology $clone -SearchServiceInstance $host1
New-SPEnterpriseSearchContentProcessingComponent –SearchTopology $clone -SearchServiceInstance $host2
New-SPEnterpriseSearchAnalyticsProcessingComponent –SearchTopology $clone -SearchServiceInstance $host2
New-SPEnterpriseSearchCrawlComponent –SearchTopology $clone -SearchServiceInstance $host2 
New-SPEnterpriseSearchIndexComponent –SearchTopology $clone -SearchServiceInstance $host1 -RootDirectory "D:\SharePointIndex\Partition 0"
New-SPEnterpriseSearchIndexComponent –SearchTopology $clone -SearchServiceInstance $host2 -RootDirectory "D:\SharePointIndex\Partition 0"
New-SPEnterpriseSearchQueryProcessingComponent –SearchTopology $clone -SearchServiceInstance $host1
New-SPEnterpriseSearchQueryProcessingComponent –SearchTopology $clone -SearchServiceInstance $host2
 
#Activate the new topology

SET-SPENTERPRISESEARCHTOPOLOGY -IDENTITY $Clone

#Remove inactive components

$sa = Get-SPEnterpriseSearchServiceApplication
foreach($topo in (Get-SPEnterpriseSearchTopology -SearchApplication $sa |
?{$_.State -eq "Inactive"}))
{
Remove-SPEnterpriseSearchTopology -Identity $topo -Confirm:$false
}

######################

#Adding a new Partition to the Search Index when data exist in the index

# Make sure the current topology is healthy
Get-SPEnterpriseSearchStatus. 
 
# Start the search service instance on all the servers that you want to add the index replica for the new index partition
 
$<host n> = Get-SPEnterpriseSearchServiceInstance -Identity "<Server name>"
Start-SPEnterpriseSearchServiceInstance -Identity $<host n>
 
$hostC = Get-SPEnterpriseSearchServiceInstance -Identity "Server3"
Start-SPEnterpriseSearchServiceInstance -Identity $hostC
$hostD = Get-SPEnterpriseSearchServiceInstance -Identity "Server4"
Start-SPEnterpriseSearchServiceInstance -Identity $hostD
 
# Wait until the search service instances are running
 
Get-SPEnterpriseSearchServiceInstance -Identity $<host n>
 
Get-SPEnterpriseSearchServiceInstance -Identity $hostC
Get-SPEnterpriseSearchServiceInstance -Identity $hostD
 
# Clone the active search topology
 
$ssa = Get-SPEnterpriseSearchServiceApplication
$active = Get-SPEnterpriseSearchTopology -SearchApplication $ssa -Active
$clone = New-SPEnterpriseSearchTopology -SearchApplication $ssa -Clone -SearchTopology $active

#Make a note of the clone's GUID

 # add a new index partition by adding one or more index components and associate them with the new index partition. We recommend that you create the same number of index replicas for the new index partition as you have for the existing partitions. For each new index component, at the Windows PowerShell command prompt, type the following command(s):
 
# If you have an existing index partition 0 with index replicas on Host A and Host B, then you’ll want to add a new index partition with index replicas on Host C and Host D:
 
New-SPEnterpriseSearchIndexComponent -SearchTopology $clone -SearchServiceInstance $hostC -IndexPartition 1
New-SPEnterpriseSearchIndexComponent -SearchTopology $clone -SearchServiceInstance $hostD -IndexPartition 1
 
# Determine if the index has fully replicated by checking that search service application is running, and do not continue until is running
# Verify that the Search service application is running. At the Windows PowerShell command prompt, type the following command(s):
 
$ssa.IsPaused() -ne 0

#If this command returns False, the Search service application is running then it is ok to continue.  However, If this command returns True, the Search service application is paused and you need to get it started before continuing, it might be paused for the repartitioning, just let it run its course. If the Search service application is paused, you need to wait for it to complete before you can continue with activating the clone.  You can use the guidance found at this post, https://technet.microsoft.com/en-us/library/dn745901.aspx, to troubleshoot a paused index.  Some of that post is also available in this chapter, a little later on.

# Once the index is fully replicated, activate the cloned topology and start the process of index repartitioning
$ssa.PauseForIndexRepartitioning()
Set-SPEnterpriseSearchTopology -Identity $clone
 
# In a new Management shell, Monitor the progress of the index re-partitioning process
#Find the primary index replica of each of the existing index partitions so you can monitor
 
$ssa = Get-SPEnterpriseSearchServiceApplication
Get-SPEnterpriseSearchStatus -SearchApplication $ssa -Text

# Monitor each primary index components repartitioning progress
 
Get-SPEnterpriseSearchStatus -SearchApplication $ssa -Healthreport -Component <Index component name> | ? { ($_.name -match "repart") -or ( $_.name -match "splitting") } | ft -AutoSize Name, Message

#Continue running this command for all primary index components until the command no longer returns any values. Once the command returns only a new line, the index repartitioning process is complete and that the repartitioned index will start replicating and getting distributed over the servers; which will more than likely consume several hours.

# Monitor the distribution of the index to the new replicas
 
# To do this, verify that your new topology is active, and that all search components are healthy. 
# At the Windows PowerShell command prompt of the second SharePoint 2013 Management Shell, type the following command(s):

Get-SPEnterpriseSearchStatus -SearchApplication $ssa | ft -AutoSize Name, State, Details

#During the distribution of the index to the new index replicas, the added index replicas will return the state Degraded. When all index components return the state Active in the output, the distribution is finished. This could take several hours.
 
# While all this is happening, you’ll see yellow triangles in your search service application, because things are not fully online.  For example, the query processing components were suspended when you have paused the Search service application for index repartitioning. This is why you’re seeing a state of Uknown in the output for the query processing components.
 
# At this point, you have two SharePoint powershell sessions open.  Go back to the original SharePoint management Shell, the first one where all this started, Verify that the search topology activation has completed.  You should see a new empty powershell line.
 
# Restart the SharePoint Search Host Controller service on all the servers that hosted index components (representing a primary index replica or any other index replica) prior to the repartitioning. 
# Perform this step to get a correct document count and free up memory after repartitioning the search index. If you decide not to perform this step, it will take a few days and some indexing iterations for the memory usage to be gradually reduced and the document count (as returned by PowerShell cmdlets and in the Search Administration page in Central Administration) to be correct.

# Resume the Search service application.
 
$ssa.ResumeAfterIndexRepartitioning()

Whew, that’s a lot of stuff to take into account!  

#####################################################################################################################

######################

#Create a replica inside an existing partition when index holds data

# Start the search service instance on all the servers that you want to add the index replica to for the existing index partition
 $HostB = Get-SPEnterpriseSearchServiceInstance -Identity "Server2"
Start-SPEnterpriseSearchServiceInstance -Identity $HostB
 
# Wait until the search service instances are running
 
Get-SPEnterpriseSearchServiceInstance -Identity $HostB
 
# Clone the active search topology
 
$ssa = Get-SPEnterpriseSearchServiceApplication
$active = Get-SPEnterpriseSearchTopology -SearchApplication $ssa -Active
$clone = New-SPEnterpriseSearchTopology -SearchApplication $ssa -Clone -SearchTopology $active

#Make a note of the clone's GUID

# Add the new index component and associate it with a partition
 
New-SPEnterpriseSearchIndexComponent -SearchTopology $clone -SearchServiceInstance $hostB -IndexPartition 0

# Activate the cloned topology
 
Set-SPEnterpriseSearchTopology -Identity $clone
 
# Verify that the new cloned topology is healthy
 
Get-SPEnterpriseSearchTopology -Active -SearchApplication $ssa
 
# Monitor the distribution of the existing index to the new replica. The added index replica will have the state Degraded until the distribution is finished. At the Windows PowerShell command prompt, type the following command(s):
 
Get-SPEnterpriseSearchStatus -SearchApplication $ssa -Text
 
# Repeat this command until all search components, including the new index component, output the state Active. For a large search index, this could take several hours.

#####################################################################################################################

######################

#Reset the search index

$ssa = Get-SPEnterpriseSearchServiceApplication

$disableAlerts = $true

$ignoreUnreachableServer = $true

$ssa.reset($disableAlerts, $ignoreUnreachableServer)

if (-not $?) {

 Write-Error “Reset failed”

}

######################

#Remove search from servers not in the topology

$svc = Get-SPEnterpriseSearchServiceInstance -Local 
$svc
$svc.Unprovision()

######################

#Stop a crawl for a specifice search service application and a specific content source

$searchapp = Get-SPEnterpriseSearchServiceApplication "NameofSearchService application"
$contentsource = Get-SPEnterpriseSearchCrawlContentSource "NameofContentsource" -SearchApplication $searchapp
$contentsource.StopCrawl()

######################

#Stop all crawls

Get-SPEnterpriseSearchCrawlContentSource -SearchApplication "SharePoint Search Service" | ForEach-Object {
    if ($_.CrawlStatus -ne "Idle")
    {
        Write-Host "Stopping currently running crawl for content source $($_.Name)..."
        $_.StopCrawl()
        
        do { Start-Sleep -Seconds 1 }
        while ($_.CrawlStatus -ne "Idle")
    }
}

######################

#Starting a stuck host node controller

$acl = Get-Acl HKLM:\System\CurrentControlSet\Control\ComputerName
    $person = [System.Security.Principal.NTAccount]"Users"
    $access = [System.Security.AccessControl.RegistryRights]::FullControl
    $inheritance = [System.Security.AccessControl.InheritanceFlags]"ContainerInherit, ObjectInherit"
    $propagation = [System.Security.AccessControl.PropagationFlags]::None
    $type = [System.Security.AccessControl.AccessControlType]::Allow
    $rule = New-Object System.Security.AccessControl.RegistryAccessRule($person, $access, $inheritance, $propagation, $type)
    $acl.AddAccessRule($rule)
    Set-Acl HKLM:\System\CurrentControlSet\Control\ComputerName $acl

    $sh = Get-SPServiceInstance | ? {$_.TypeName -eq "Search Host Controller Service"}
    $sh.Unprovision()
    $sh.Provision($true)

#####################################################################################################################

######################

#Super search info powershell

<# 
.SYNOPSIS 
       The purpose of this SharePoint 2013 script is to present the status of the Search  
       Service Application, with main focus on the state of the search topology.  
.DESCRIPTION 
       The script consolidates data from multiple cmdlets and sources:
       - Key topology status data from Get-SPEnterpriseSearchStatus
             Get-SPEnterpriseSearchStatus -SearchApplication $ssa
             Get-SPEnterpriseSearchStatus -SearchApplication $ssa -Primary -<Admin Component>
             Get-SPEnterpriseSearchStatus -SearchApplication $ssa -JobStatus
             Get-SPEnterpriseSearchStatus -SearchApplication $ssa -HealthReport -Component <Search Component>
                 Printing selected info relevant for degraded states
       - Crawl status (crawling/idle/paused)
             $ssa.Ispaused()
             $contentSource.CrawlState
       - Number of indexed documents including index size alert (currently 10 mill. items per partition)
             Using Get-SPEnterpriseSearchStatus -SearchApplication $ssa -HealthReport -Component <Search Component>
       - HA status for topology, indicating which roles that may not have high availability
             Aggregated status info from Get-SPEnterpriseSearchStatus
       - Host controller repository status (for search dictionaries)
             Get-SPEnterpriseSearchHostController
 
       Limitations:
       - The script only supports one SSA in the farm. 
         If multiple SSAs found, the script prints status for the first SSA found.
.NOTES 
  File Name : Get-SPSearchTopologyState.ps1 
  Tags      : SharePoint 2013, Enterprise Search, SP2013ES 
 
#> 
 
# ==================================================================================================================
# Get status for search topology
# ==================================================================================================================
 
# --------------------------------------------------------------------------
#  Writes error message to the user in red color and exits the script.
# --------------------------------------------------------------------------
Function WriteErrorAndExit($errorText)
{
    Write-Host -BackgroundColor Red -ForegroundColor Black $errorText
    Write-Host -BackgroundColor Red -ForegroundColor Black "Aborting script"
    exit
}
 
# ------------------------------------------------------------------------------------------------------------------
# GetSSA: Get SSA reference 
# ------------------------------------------------------------------------------------------------------------------
Function GetSSA
{
    $ssas = @(Get-SPEnterpriseSearchServiceApplication)
    if ($ssas.Count -ne 1)
    {
        WriteErrorAndExit("This script only supports a single SSA configuration")
    }
 
    $global:ssa = $ssas[0]
    if ($global:ssa.Status -ne "Online")
    {
        $ssaStat = $global:ssa.Status
        WriteErrorAndExit("Expected SSA to have status 'Online', found status: $ssaStat")
    }
 
    Write-Output "SSA: $($global:ssa.Name)"
    Write-Output ""
}
 
# ------------------------------------------------------------------------------------------------------------------
# GetCrawlStatus: Get crawl status
# ------------------------------------------------------------------------------------------------------------------
Function GetCrawlStatus
{
    if ($global:ssa.Ispaused())
    {
        switch ($global:ssa.Ispaused()) 
        { 
            1       { $pauseReason = "ongoing search topology operation" } 
            2       { $pauseReason = "backup/restore" } 
            4       { $pauseReason = "backup/restore" } 
            32      { $pauseReason = "crawl DB re-factoring" } 
            64      { $pauseReason = "link DB re-factoring" } 
            128     { $pauseReason = "external reason (user initiated)" } 
            256     { $pauseReason = "index reset" } 
            512     { $pauseReason = "index re-partitioning (query is also paused)" } 
            default { $pauseReason = "multiple reasons ($($global:ssa.Ispaused()))" } 
        }
        Write-Output "$($global:ssa.Name): Paused for $pauseReason"
    }
    else
    {
        $crawling = $false
        $contentSources = Get-SPEnterpriseSearchCrawlContentSource -SearchApplication $global:ssa
        if ($contentSources) 
        {
            foreach ($source in $contentSources)
            {
                if ($source.CrawlState -ne "Idle")
                {
                    Write-Output "Crawling $($source.Name) : $($source.CrawlState)"
                    $crawling = $true
                }
            }
            if (! $crawling)
            {
                Write-Output "Crawler is idle"
            }
        }
        else
        {
            Write-Output "Crawler: No content sources found"
        }
    }
}
 
# ------------------------------------------------------------------------------------------------------------------
# GetTopologyInfo: Get basic topology info and component health status
# ------------------------------------------------------------------------------------------------------------------
Function GetTopologyInfo
{
    $at = Get-SPEnterpriseSearchTopology -SearchApplication $global:ssa -Active
    $global:topologyCompList = Get-SPEnterpriseSearchComponent -SearchTopology $at
 
    # Check if topology is prepared for HA
    $adminFound = $false
    foreach ($searchComp in ($global:topologyCompList))
    {
        if ($searchComp.Name -match "Admin")
        { 
            if ($adminFound) 
            { 
                $global:haTopology = $true 
            } 
            else
            {
                $adminFound = $true
            }
        }
    }    
 
    #
    # Get topology component state:
    #
    $global:componentStateList=Get-SPEnterpriseSearchStatus -SearchApplication $global:ssa
 
    # Find the primary admin component:
    foreach ($component in ($global:componentStateList))
    {
        if ( ($component.Name -match "Admin") -and ($component.State -ne "Unknown") )
        {
            if (Get-SPEnterpriseSearchStatus -SearchApplication $global:ssa -Primary -Component $($component.Name))
            {
                $global:primaryAdmin = $component.Name
            }
        }
    }    
    if (! $global:primaryAdmin)
    {
        Write-Output ""
        Write-Output "-----------------------------------------------------------------------------"
        Write-Output "Error: Not able to obtain health state information."
        Write-Output "Recommended action: Ensure that at least one admin component is operational."
        Write-Output "This state may also indicate that an admin component failover is in progress."
        Write-Output "-----------------------------------------------------------------------------"
        Write-Output ""
        throw "Search component health state check failed"
    }
}
 
# ------------------------------------------------------------------------------------------------------------------
# PopulateHostHaList: For each component, determine properties and update $global:hostArray / $global:haArray
# ------------------------------------------------------------------------------------------------------------------
Function PopulateHostHaList($searchComp)
{
        if ($searchComp.ServerName)
        {
            $hostName = $searchComp.ServerName
        }
        else
        {
            $hostName = "Unknown server"
        }
        $partition = $searchComp.IndexPartitionOrdinal
        $newHostFound = $true
        $newHaFound = $true
        $entity = $null
 
        foreach ($searchHost in ($global:hostArray))
        {
            if ($searchHost.hostName -eq $hostName)
            {
                $newHostFound = $false
            }
        }
        if ($newHostFound)
        {
            # Add the host to $global:hostArray
            $hostTemp = $global:hostTemplate | Select-Object *
            $hostTemp.hostName = $hostName
            $global:hostArray += $hostTemp
            $global:searchHosts += 1
        }
 
        # Fill in component specific data in $global:hostArray
        foreach ($searchHost in ($global:hostArray))
        {
            if ($searchHost.hostName -eq $hostName)
            {
                $partition = -1
                if ($searchComp.Name -match "Query") 
                { 
                    $entity = "QueryProcessingComponent" 
                    $searchHost.qpc = "QueryProcessing "
                    $searchHost.components += 1
                }
                elseif ($searchComp.Name -match "Content") 
                { 
                    $entity = "ContentProcessingComponent" 
                    $searchHost.cpc = "ContentProcessing "
                    $searchHost.components += 1
                }
                elseif ($searchComp.Name -match "Analytics") 
                { 
                    $entity = "AnalyticsProcessingComponent" 
                    $searchHost.apc = "AnalyticsProcessing "
                    $searchHost.components += 1
                }
                elseif ($searchComp.Name -match "Admin") 
                { 
                    $entity = "AdminComponent" 
                    if ($searchComp.Name -eq $global:primaryAdmin)
                    {
                        $searchHost.pAdmin = "Admin(Primary) "
                    }
                    else
                    {
                        $searchHost.sAdmin = "Admin "
                    }
                    $searchHost.components += 1
                }
                elseif ($searchComp.Name -match "Crawl") 
                { 
                    $entity = "CrawlComponent" 
                    $searchHost.crawler = "Crawler "
                    $searchHost.components += 1
                }
                elseif ($searchComp.Name -match "Index") 
                { 
                    $entity = "IndexComponent"
                    $partition = $searchComp.IndexPartitionOrdinal
                    $searchHost.index = "IndexPartition($partition) "
                    $searchHost.components += 1
                }
            }
        }
    
        # Fill in component specific data in $global:haArray
        foreach ($haEntity in ($global:haArray))
        {
            if ($haEntity.entity -eq $entity)
            {
                if ($entity -eq "IndexComponent")
                {
                    if ($haEntity.partition -eq $partition)
                    {
                        $newHaFound = $false
                    }
                }
                else 
                { 
                    $newHaFound = $false
                }
            }
        }
        if ($newHaFound)
        {
            # Add the HA entities to $global:haArray
            $haTemp = $global:haTemplate | Select-Object *
            $haTemp.entity = $entity
            $haTemp.components = 1
            if ($partition -ne -1) 
            { 
                $haTemp.partition = $partition 
            }
            $global:haArray += $haTemp
        }
        else
        {
            foreach ($haEntity in ($global:haArray))
            {
                if ($haEntity.entity -eq $entity) 
                {
                    if (($entity -eq "IndexComponent") )
                    {
                        if ($haEntity.partition -eq $partition)
                        {
                            $haEntity.components += 1
                        }
                    }
                    else
                    {
                        $haEntity.components += 1
                        if (($haEntity.entity -eq "AdminComponent") -and ($searchComp.Name -eq $global:primaryAdmin))
                        {
                            $haEntity.primary = $global:primaryAdmin
                        }
                    }
                }
            }
        }
}
 
# ------------------------------------------------------------------------------------------------------------------
# AnalyticsStatus: Output status of analytics jobs
# ------------------------------------------------------------------------------------------------------------------
Function AnalyticsStatus
{
    Write-Output "Analytics Processing Job Status:"
    $analyticsStatus = Get-SPEnterpriseSearchStatus -SearchApplication $global:ssa -JobStatus
 
    foreach ($analyticsEntry in $analyticsStatus)
    {
        if ($analyticsEntry.Name -ne "Not available")     
        {
            foreach ($de in ($analyticsEntry.Details))
            {
                if ($de.Key -eq "Status")
                {
                    $status = $de.Value
                }
            }
            Write-Output "    $($analyticsEntry.Name) : $status"
        }
        # Output additional diagnostics from the dictionary
        foreach ($de in ($analyticsEntry.Details))
        {
            # Skip entries that is listed as Not Available
            if ( ($de.Value -ne "Not available") -and ($de.Key -ne "Activity") -and ($de.Key -ne "Status") )
            {
                Write-Output "        $($de.Key): $($de.Value)"
                if ($de.Key -match "Last successful start time")
                {
                    $dLast = Get-Date $de.Value
                    $dNow = Get-Date
                    $daysSinceLastSuccess = $dNow.DayOfYear - $dLast.DayOfYear
                    if ($daysSinceLastSuccess -gt 3)
                    {
                        Write-Output "        Warning: More than three days since last successful run"
                        $global:serviceDegraded = $true                        
                    }
                }
            }
        }
    }
    Write-Output ""
}
 
# ------------------------------------------------------------------------------------------------------------------
# SearchComponentStatus: Analyze the component status for one component
# ------------------------------------------------------------------------------------------------------------------
Function SearchComponentStatus($component)
{
    # Find host name
    foreach($searchComp in ($global:topologyCompList))
    {
        if ($searchComp.Name -eq $component.Name)
        {
            if ($searchComp.ServerName)
            {
                $hostName = $searchComp.ServerName
            }
            else
            {
                $hostName = "No server associated with this component. The server may have been removed from the farm."
            }
        }
    }
    if ($component.State -ne "Active")
    {
        # String with all components that is not active:
        if ($component.State -eq "Unknown")
        {
            $global:unknownComponents += "$($component.Name):$($component.State)"
        }
        elseif ($component.State -eq "Degraded")
        {
            $global:degradedComponents += "$($component.Name):$($component.State)"
        }
        else
        {
            $global:failedComponents += "$($component.Name):$($component.State)"
        }
        $global:serviceDegraded = $true
    }
    
    # Skip unnecessary info about cells and partitions if everything is fine
    $outputEntry = $true
    
    # Indent the cell info, logically belongs to the component. 
    if ($component.Name -match "Cell")
    {
        if ($component.State -eq "Active")
        {
            $outputEntry = $false
        }
        else
        {
            Write-Output "    $($component.Name)"
        }
    }
    elseif ($component.Name -match "Partition")
    {
        if ($component.State -eq "Active")
        {
            $outputEntry = $false
        }
        else
        {
            Write-Output "Index $($component.Name)"
        }
    }
    else
    {
        # State for search components
        $primaryString = ""
        if ($component.Name -match "Query") { $entity = "QueryProcessingComponent" }
        elseif ($component.Name -match "Content") { $entity = "ContentProcessingComponent" }
        elseif ($component.Name -match "Analytics") { $entity = "AnalyticsProcessingComponent" }
        elseif ($component.Name -match "Crawl") { $entity = "CrawlComponent" }
        elseif ($component.Name -match "Admin") 
        { 
            $entity = "AdminComponent" 
            if ($global:haTopology)
            {
                if ($component.Name -eq $global:primaryAdmin)
                {
                    $primaryString = " (Primary)"
                }
            }
        }
        elseif ($component.Name -match "Index") 
        { 
            $entity = "IndexComponent"
            foreach ($searchComp in ($global:topologyCompList))
            {
                if ($searchComp.Name -eq $component.Name) 
                {
                    $partition = $searchComp.IndexPartitionOrdinal
                }
            }
            # find info about primary role
            foreach ($de in ($component.Details))
            {
                if ($de.Key -eq "Primary")
                {
                    if ($de.Value -eq "True")
                    {
                        $primaryString = " (Primary)"
                        foreach ($haEntity in ($global:haArray))
                        {
                            if (($haEntity.entity -eq $entity) -and ($haEntity.partition -eq $partition))
                            {
                                $haEntity.primary = $component.Name
 
                            }
                        }                        
                    }
                }
            }
        }
        foreach ($haEntity in ($global:haArray))
        {
            if ( ($haEntity.entity -eq $entity) -and ($component.State -eq "Active") )
            {
                if ($entity -eq "IndexComponent")
                {
                    if ($haEntity.partition -eq $partition)
                    {
                        $haEntity.componentsOk += 1
                    }
                }
                else 
                { 
                    $haEntity.componentsOk += 1
                }
            }
        }
        # Add the component entities to $global:compArray for output formatting
        $compTemp = $global:compTemplate | Select-Object *
        $compTemp.Component = "$($component.Name)$primaryString"
        $compTemp.Server = $hostName
        $compTemp.State = $component.State
        if ($partition -ne -1) 
        { 
            $compTemp.Partition = $partition 
        }
        $global:compArray += $compTemp
 
        if ($component.State -eq "Active")
        {
            $outputEntry = $false
        }
        else
        {
            Write-Output "$($component.Name)"
        }
    }
    if ($outputEntry)
    {
        if ($component.State)
        {
            Write-Output "    State: $($component.State)"
        }
        if ($hostName)
        {
            Write-Output "    Server: $hostName"
        }
        if ($component.Message)
        {
            Write-Output "    Details: $($component.Message)"
        }
    
        # Output additional diagnostics from the dictionary
        foreach ($de in ($component.Details))
        {
            if ($de.Key -ne "Host")
            {
                Write-Output "    $($de.Key): $($de.Value)"
            }
        }
        if ($global:haTopology)
        {
            if ($component.Name -eq $global:primaryAdmin)
            {
                Write-Output "    Primary: True"            
            }
            elseif ($component.Name -match "Admin")
            {
                Write-Output "    Primary: False"            
            }
        }
    }
}
 
# ------------------------------------------------------------------------------------------------------------------
# DetailedIndexerDiag: Output selected info from detailed component diag
# ------------------------------------------------------------------------------------------------------------------
Function DetailedIndexerDiag
{
    $indexerInfo = @()
    $generationInfo = @()
    $generation = 0
 
    foreach ($searchComp in ($global:componentStateList))
    {
        $component = $searchComp.Name
        if ( (($component -match "Index") -or ($component -match "Content") -or ($component -match "Admin")) -and ($component -notmatch "Cell") -and ($searchComp.State -notmatch "Unknown") -and ($searchComp.State -notmatch "Registering"))
        {
            $pl=Get-SPEnterpriseSearchStatus -SearchApplication $global:ssa -HealthReport -Component $component
            foreach ($entry in ($pl))
            {
                if ($entry.Name -match "plugin: number of documents") 
                { 
                    foreach ($haEntity in ($global:haArray))
                    {
                        if (($haEntity.entity -eq "IndexComponent") -and ($haEntity.primary -eq $component))
                        {
                            # Count indexed documents from all index partitions:
                            $global:indexedDocs += $entry.Message
                            $haEntity.docs = $entry.Message
                        }
                    }
                }
                if ($entry.Name -match "repartition")
                    { $indexerInfo += "Index re-partitioning state: $($entry.Message)" }
                elseif (($entry.Name -match "splitting") -and ($entry.Name -match "fusion")) 
                    { $indexerInfo += "$component : Splitting index partition (appr. $($entry.Message) % finished)" }
                elseif (($entry.Name -match "master merge running") -and ($entry.Message -match "true")) 
                { 
                    $indexerInfo += "$component : Index Master Merge (de-fragment index files) in progress" 
                    $global:masterMerge = $true
                }
                elseif ($global:degradedComponents -and ($entry.Name -match "plugin: newest generation id"))
                {
                    # If at least one index component is left behind, we want to output the generation number.  
                    $generationInfo += "$component : Index generation: $($entry.Message)" 
                    $gen = [int] $entry.Message
                    if ($generation -and ($generation -ne $gen))
                    {
                        # Verify if there are different generation IDs for the indexers
                        $global:generationDifference = $true
                    }
                    $generation = $gen
                }
                elseif (($entry.Level -eq "Error") -or ($entry.Level -eq "Warning"))
                {
                    $global:serviceDegraded = $true
                    if ($entry.Name -match "fastserver")
                        { $indexerInfo += "$component ($($entry.Level)) : Indexer plugin error ($($entry.Name):$($entry.Message))" }
                    elseif ($entry.Message -match "fragments")
                        { $indexerInfo += "$component ($($entry.Level)) : Missing index partition" }
                    elseif (($entry.Name -match "active") -and ($entry.Message -match "not active"))
                        { $indexerInfo += "$component ($($entry.Level)) : Indexer generation controller is not running. Potential reason: All index partitions are not available" }
                    elseif ( ($entry.Name -match "in_sync") -or ($entry.Name -match "left_behind") )
                    { 
                        # Indicates replicas are out of sync, catching up. Redundant info in this script
                        $global:indexLeftBehind = $true
                    }                
                    elseif ($entry.Name -match "full_queue")
                        { $indexerInfo += "$component : Items queuing up in feeding ($($entry.Message))" }                                
                    elseif ($entry.Message -notmatch "No primary")
                    {
                        $indexerInfo += "$component ($($entry.Level)) : $($entry.Name):$($entry.Message)"
                    }
                }
            }
        }
    } 
 
    if ($indexerInfo)
    {
        Write-Output ""
        Write-Output "Indexer related additional status information:"
        foreach ($indexerInfoEntry in ($indexerInfo))
        {        
            Write-Output "    $indexerInfoEntry"
        }
        if ($global:indexLeftBehind -and $global:generationDifference)
        {
            # Output generation number for indexers in case any of them have been reported as left behind, and reported generation IDs are different.
            foreach ($generationInfoEntry in ($generationInfo))
            {        
                Write-Output "    $generationInfoEntry"
            }
        }
        Write-Output ""
    }
}
 
# ------------------------------------------------------------------------------------------------------------------
# VerifyHaLimits: Verify HA status for topology and index size limits
# ------------------------------------------------------------------------------------------------------------------
Function VerifyHaLimits
{
    $hacl = @()
    $haNotOk = $false
    $ixcwl = @()
    $ixcel = @()
    $docsExceeded = $false
    $docsHigh = $false
    foreach ($hac in $global:haArray)
    {
        if ([int] $hac.componentsOk -lt 2)
        {
            if ([int] $hac.componentsOk -eq 0)
            {
                # Service is down
                $global:serviceFailed = $true
                $haNotOk = $true   
            }
            elseif ($global:haTopology)
            {
                # Only relevant to output if we have a HA topology in the first place
                $haNotOk = $true   
            }
 
            if ($hac.partition -ne -1)
            {
                $hacl += "$($hac.componentsOk)($($hac.components)) : Index partition $($hac.partition)"
            }
            else
            {
                $hacl += "$($hac.componentsOk)($($hac.components)) : $($hac.entity)"
            }
        }
        if ([int] $hac.docs -gt 10000000)
        {
            $docsExceeded = $true 
            $ixcel += "$($hac.entity) (partition $($hac.partition)): $($hac.docs)"
        }
        elseif ([int] $hac.docs -gt 9000000)
        {
            $docsHigh = $true   
            $ixcwl += "$($hac.entity) (partition $($hac.partition)): $($hac.docs)"
        }
    }
    if ($haNotOk)
    {
        $hacl = $hacl | sort
        if ($global:serviceFailed)
        {
            Write-Output "Critical: Service down due to components not active:"
        }
        else
        {
            Write-Output "Warning: No High Availability for one or more components:"
        }
        foreach ($hc in $hacl)
        {
            Write-Output "    $hc"
        }
        Write-Output ""
    }
    if ($docsExceeded)
    {
        $global:serviceDegraded = $true
        Write-Output "Warning: One or more index component exceeds document limit:"
        foreach ($hc in $ixcel)
        {
            Write-Output "    $hc"
        }
        Write-Output ""
    }
    if ($docsHigh)
    {
        Write-Output "Warning: One or more index component is close to document limit:"
        foreach ($hc in $ixcwl)
        {
            Write-Output "    $hc"
        }
        Write-Output ""
    }
}
 
# ------------------------------------------------------------------------------------------------------------------
# VerifyHostControllerRepository: Verify that Host Controller HA (for dictionary repository) is OK
# ------------------------------------------------------------------------------------------------------------------
Function VerifyHostControllerRepository
{
    $highestRepVer = 0
    $hostControllers = 0
    $primaryRepVer = -1
    $hcStat = @()
    $hcs = Get-SPEnterpriseSearchHostController
    foreach ($hc in $hcs)
    {
        $hostControllers += 1
        $repVer = $hc.RepositoryVersion
        $serverName = $hc.Server.Name
        if ($repVer -gt $highestRepVer)
        {
            $highestRepVer = $repVer
        }
        if ($hc.PrimaryHostController)
        {
            $primaryHC = $serverName
            $primaryRepVer = $repVer
        }
        if ($repVer -ne -1)
        {
            $hcStat += "        $serverName : $repVer"
        }
    }
    if ($hostControllers -gt 1)
    {
        Write-Output "Primary search host controller (for dictionary repository): $primaryHC"
        if ($primaryRepVer -eq -1)
        {
            $global:serviceDegraded = $true
            Write-Output "Warning: Primary host controller is not available."
            Write-Output "    Recommended action: Restart server or set new primary host controller using Set-SPEnterpriseSearchPrimaryHostController."
            Write-Output "    Repository version for existing host controllers:"
            foreach ($hcs in $hcStat)
            {
                Write-Output $hcs
            }
        }
        elseif ($primaryRepVer -lt $highestRepVer)
        {
            $global:serviceDegraded = $true
            Write-Output "Warning: Primary host controller does not have the latest repository version."
            Write-Output "    Primary host controller repository version: $primaryRepVer"
            Write-Output "    Latest repository version: $highestRepVer"
            Write-Output "    Recommended action: Set new primary host controller using Set-SPEnterpriseSearchPrimaryHostController."
            Write-Output "    Repository version for existing host controllers:"
            foreach ($hcs in $hcStat)
            {
                Write-Output $hcs
            }
        }
        Write-Output ""
    }
}
 
#---added by bspender--------------------------------------------------------------------------------------------------
# VerifyApplicationServerSyncJobsEnabled: Verify that Application Server Admin Service Timer Jobs are running
# ---------------------------------------------------------------------------------------------------------------------
function VerifyApplicationServerSyncJobsEnabled
{
$timeThresholdInMin = 5
 
$sspJob = $((Get-SPFarm).Services | where {$_.TypeName -like "SSP Job Control*"})
if ($sspJob.Status -ne "Online") { 
Write-Warning ("SSP Job Control Service is " + $sspJob.Status)
$global:serviceDegraded = $true
}
 
$serverNames = $((Get-SPFarm).Servers | Where {$_.Role -eq "Application"}).Name
foreach ($server in $serverNames) {
$sspJobServiceInstance = $((Get-SPFarm).Servers[$server].ServiceInstances | where {$_.TypeName -like "SSP Job Control*"})
if ($sspJobServiceInstance.Status -ne "Online") { 
Write-Warning ("SSP Job Control Service Instance is " + $sspJobServiceInstance.Status + " on " + $server)
$global:SSPJobInstancesOffline.Add($sspJobServiceInstance) | Out-Null
$global:serviceDegraded = $true
} 
}
 
if ($serverNames.count -eq 1) {
$jobs = Get-SPTimerJob | where {$_.Name -like "job-application-*"}
} else {
$jobs = Get-SPTimerJob | where {$_.Name -eq "job-application-server-admin-service"}
}
 
foreach ($j in $jobs) { 
Write-Host ($j.Name)
Write-Host ("-------------------------------------")
if (($j.Status -ne "Online") -or ($j.isDisabled)) { 
if ($j.Status -ne "Online") { Write-Warning ($j.Name + " timer job is " + $j.Status) }
if ($j.isDisabled) { Write-Warning ($j.Name + " timer job is DISABLED") }
$global:ApplicationServerSyncTimerJobsOffline.Add($j) | Out-Null 
$global:serviceDegraded = $true
} else {
$mostRecent = $j.HistoryEntries | select -first ($serverNames.count * $timeThresholdInMin) 
foreach ($server in $serverNames) { 
$displayShorthand = $server+": "+$($j.Name)
$mostRecentOnServer = $mostRecent | Where {$_.ServerName -ieq $server} | SELECT -First 1
if ($mostRecentOnServer -eq $null) {
Write-Warning ($displayShorthand + " timer job does not appear to be running")
#and add this server to the list
$global:ApplicationServerSyncNotRunning.Add($displayShorthand) | Out-Null
$global:serviceDegraded = $true
} else {
$spanSinceLastRun = [int]$(New-TimeSpan $mostRecentOnServer.EndTime $(Get-Date).ToUniversalTime()).TotalSeconds
if ($spanSinceLastRun -lt ($timeThresholdInMin * 60)) {
Write-Host ($displayShorthand + " recently ran " + $spanSinceLastRun + " seconds ago")
} else {
Write-Warning ($displayShorthand + " last ran " + $spanSinceLastRun + " seconds ago")
$global:ApplicationServerSyncNotRunning.Add($displayShorthand) | Out-Null
}
#(For added verbosity, uncomment the following line to report the last successful run for this server) 
#$mostRecentOnServer                
}                
}        
}
}
}
 
 
# ------------------------------------------------------------------------------------------------------------------
# Main
# ------------------------------------------------------------------------------------------------------------------
 
Write-Output ""
Write-Output "Search Topology health check"
Write-Output "============================"
Write-Output ""
Get-Date
# ------------------------------------------------------------------------------------------------------------------
# Global variables:
# ------------------------------------------------------------------------------------------------------------------
 
$global:serviceDegraded = $false
$global:serviceFailed = $false
$global:unknownComponents = @()
$global:degradedComponents = @()
$global:failedComponents = @()
$global:generationDifference = $false
$global:indexLeftBehind = $false
$global:searchHosts = 0
$global:ssa = $null
$global:componentStateList = $null
$global:topologyCompList = $null
$global:haTopology = $false
$global:primaryAdmin = $null
$global:indexedDocs = 0
$global:masterMerge = $false
 
#---added by bspender------------------------
$global:SSPJobInstancesOffline = $(New-Object System.Collections.ArrayList)
$global:ApplicationServerSyncTimerJobsOffline = $(New-Object System.Collections.ArrayList)
$global:ApplicationServerSyncNotRunning = $(New-Object System.Collections.ArrayList)
#--------------------------------------------
 
# Template object for the host array:
$global:hostTemplate = New-Object psobject
$global:hostTemplate | Add-Member -MemberType NoteProperty -Name hostName -Value $null
$global:hostTemplate | Add-Member -MemberType NoteProperty -Name components -Value 0
$global:hostTemplate | Add-Member -MemberType NoteProperty -Name cpc -Value $null
$global:hostTemplate | Add-Member -MemberType NoteProperty -Name qpc -Value $null
$global:hostTemplate | Add-Member -MemberType NoteProperty -Name pAdmin -Value $null
$global:hostTemplate | Add-Member -MemberType NoteProperty -Name sAdmin -Value $null
$global:hostTemplate | Add-Member -MemberType NoteProperty -Name apc -Value $null
$global:hostTemplate | Add-Member -MemberType NoteProperty -Name crawler -Value $null
$global:hostTemplate | Add-Member -MemberType NoteProperty -Name index -Value $null
 
# Create the empty host array:
$global:hostArray = @()
 
# Template object for the HA group array:
$global:haTemplate = New-Object psobject
$global:haTemplate | Add-Member -MemberType NoteProperty -Name entity -Value $null
$global:haTemplate | Add-Member -MemberType NoteProperty -Name partition -Value -1
$global:haTemplate | Add-Member -MemberType NoteProperty -Name primary -Value $null
$global:haTemplate | Add-Member -MemberType NoteProperty -Name docs -Value 0
$global:haTemplate | Add-Member -MemberType NoteProperty -Name components -Value 0
$global:haTemplate | Add-Member -MemberType NoteProperty -Name componentsOk -Value 0
 
# Create the empty HA group array:
$global:haArray = @()
 
# Template object for the component/server table:
$global:compTemplate = New-Object psobject
$global:compTemplate | Add-Member -MemberType NoteProperty -Name Component -Value $null
$global:compTemplate | Add-Member -MemberType NoteProperty -Name Server -Value $null
$global:compTemplate | Add-Member -MemberType NoteProperty -Name Partition -Value $null
$global:compTemplate | Add-Member -MemberType NoteProperty -Name State -Value $null
 
# Create the empty component/server table:
$global:compArray = @()
 
# Get the SSA object and print SSA name:
GetSSA
 
VerifyApplicationServerSyncJobsEnabled
 
# Get basic topology info and component health status
GetTopologyInfo
 
# Traverse list of components, determine properties and update $global:hostArray / $global:haArray
foreach ($searchComp in ($global:topologyCompList))
{
    PopulateHostHaList($searchComp)
}
 
# Analyze the component status:
foreach ($component in ($global:componentStateList))
{
    SearchComponentStatus($component)
}
 
# Look for selected info from detailed indexer diagnostics:
DetailedIndexerDiag
 
# Output list of components with state OK:
if ($global:compArray)
{
    $global:compArray | Sort-Object -Property Component | Format-Table -AutoSize
}
Write-Output ""
 
# Verify HA status for topology and index size limits:
VerifyHaLimits
 
# Verify that Host Controller HA (for dictionary repository) is OK:
VerifyHostControllerRepository
 
# Output components by server (for servers with multiple search components):
if ($global:haTopology -and ($global:searchHosts -gt 2))
{
    $componentsByServer = $false
    foreach ($hostInfo in $global:hostArray)
    {
        if ([int] $hostInfo.components -gt 1)
        {
            $componentsByServer = $true
        }
    }
    if ($componentsByServer)
    {
        Write-Output "Servers with multiple search components:"
        foreach ($hostInfo in $global:hostArray)
        {
            if ([int] $hostInfo.components -gt 1)
            {
                Write-Output "    $($hostInfo.hostName): $($hostInfo.pAdmin)$($hostInfo.sAdmin)$($hostInfo.index)$($hostInfo.qpc)$($hostInfo.cpc)$($hostInfo.apc)$($hostInfo.crawler)"
            }
        }
        Write-Output ""
    }
}
 
# Analytics Processing Job Status:
AnalyticsStatus
 
if ($global:masterMerge)
{
    Write-Output "Index Master Merge (de-fragment index files) in progress on one or more index components."
}
 
if ($global:serviceFailed -eq $false)
{
    Write-Output "Searchable items: $global:indexedDocs"
}
 
GetCrawlStatus
Write-Output ""
    
if ($global:unknownComponents)
{
    Write-Output "The following components are not reachable:"
    foreach ($uc in ($global:unknownComponents))
    {
        Write-Output "    $uc"
    }
    Write-Output "Recommended action: Restart or replace the associated server(s)"
    Write-Output ""
}
 
if ($global:degradedComponents)
{
    Write-Output "The following components are degraded:"
    foreach ($dc in ($global:degradedComponents))
    {
        Write-Output "    $dc"
    }
    Write-Output "Recommended action for degraded components:"
    Write-Output "    Component registering or resolving:"
    Write-Output "        This is normally a transient state during component restart or re-configuration. Re-run the script."
 
    if ($global:indexLeftBehind)
    {
        Write-Output "    Index component left behind:"
        if ($global:generationDifference)
        {
            Write-Output "        This is normal after adding an index component or index component/server recovery."
            Write-Output "        Indicates that the replica is being updated from the primary replica."
        }
        else
        {
            Write-Output "        Index replicas listed as degraded but index generation is OK."
            Write-Output "        Will get out of degraded state as soon as new/changed items are being idexed."
        }
    }
    Write-Output ""
}
 
if ($global:failedComponents)
{
    Write-Output "The following components are reported in error:"
    foreach ($fc in ($global:failedComponents))
    {
        Write-Output "    $fc"
    }
    Write-Output "Recommended action: Restart the associated server(s)"
    Write-Output ""
}
 
if ($global:serviceFailed)
{
    Write-Host -BackgroundColor Red -ForegroundColor Black "Search service overall state: Failed (no queries served)"
}
elseif ($global:serviceDegraded)
{
    Write-Host -BackgroundColor Yellow -ForegroundColor Black "Search service overall state: Degraded"
}
else
{
    Write-Host -BackgroundColor Green -ForegroundColor Black "Search service overall state: OK"
}
Write-Output ""

#####################################################################################################################

######################

#Adding a crawl DB

$SSA = Get-SPEnterpriseSearchServiceApplication 
$searchCrawlDBName = "SharePoint_Search_Service_CrawlDB2"
$searchCrawlDBServer = "SharePointSQL"
$crawlDatabase = New-SPEnterpriseSearchCrawlDatabase -SearchApplication $SSA -DatabaseName $searchCrawlDBName -DatabaseServer $searchCrawlDBServer
$crawlStoresManager = new-Object Microsoft.Office.Server.Search.Administration.CrawlStorePartitionManager($SSA)
$crawlStoresManager.BeginCrawlStoreRebalancing()

######################

#Check status of adding the crawl db

cls
$SSA = Get-SPEnterpriseSearchServiceApplication
$crawlStoresManager = new-Object Microsoft.Office.Server.Search.Administration.CrawlStorePartitionManager($SSA)
Write-Host "CrawlStoresAreUnbalanced:" $crawlStoresManager.CrawlStoresAreUnbalanced()
Write-Host "CrawlStoreImbalanceThreshold:" $ssa.GetProperty("CrawlStoreImbalanceThreshold")
Write-Host "CrawlStoresAreUnbalanced:" $crawlStoresManager.CrawlStoresAreUnbalanced()
Write-Host "CrawlPartitionSplitThreshold:" $ssa.GetProperty("CrawlPartitionSplitThreshold")
$crawlLog = New-Object Microsoft.Office.Server.Search.Administration.CrawlLog $SSA
$dbInfo= $crawlLog.GetCrawlDatabaseInfo()
Write-Host "Number of Crawl Databases:"
$dbInfo.Count
$dbInfo.Values

######################

#Adding analytics component database

$SSA = Get-SPEnterpriseSearchServiceApplication 
New-SPEnterpriseSearchLinksDatabase -DatabaseName LinksDB_2 -SearchApplication $SSA


#####################################################################################################################

######################

#Creating a fresh SSA

####Run with an account that is a farm admin, use the search service account for the app pool user####

$ssaAppPoolName = "SharePoint Search Service Application Pool"
$SearchappPoolUserName = "Contoso\2013Search"

$ssaAppPool = Get-SPServiceApplicationPool -Identity $ssaAppPoolName -EA 0
if($ssaAppPool -eq $null)
{
Write-Host "Creating Search Service Application Pool…"
 
$SearchappPoolAccount = Get-SPManagedAccount -Identity $SearchappPoolUserName -EA 0
if($SearchappPoolAccount -eq $null)
{
Write-Host "Please supply the password for the Service Account…"
$ssappPoolCred = Get-Credential $SearchappPoolUserName
$SearchappPoolAccount = New-SPManagedAccount -Credential $ssappPoolCred -EA 0
}
 
$SearchappPoolAccount = Get-SPManagedAccount -Identity $SearchappPoolUserName -EA 0
 
if($SearchappPoolAccount -eq $null)
{
Write-Host "Cannot create or find the managed account $SearchappPoolUserName, please ensure the account exists."
Exit -1
}
 
New-SPServiceApplicationPool -Name $ssaAppPoolName -Account $SearchappPoolAccount -EA 0 > $null
 
}
 
## Search Specifics, we are single server farm ##
 
$searchServerName = (Get-ChildItem env:computername).value
 
$serviceAppName = "Enterprise Search Services"
 
$searchDBName = "Search"
 
 
## Grab the Application Pool for Service Application Endpoint ##
 
$ssaAppPool = Get-SPServiceApplicationPool $ssaAppPoolName
 
## Start Search Service Instances ##
 
Write-Host "Starting Search Service Instances..."
 
Start-SPEnterpriseSearchServiceInstance $searchServerName
 
Start-SPEnterpriseSearchQueryAndSiteSettingsServiceInstance $searchServerName
 
## Create the Search Service Application and Proxy ##
 
Write-Host "Creating Search Service Application and Proxy..."
 
$searchServiceApp = New-SPEnterpriseSearchServiceApplication -Name $serviceAppName -ApplicationPool $ssaAppPoolName -DatabaseName $searchDBName
 
$searchProxy = New-SPEnterpriseSearchServiceApplicationProxy -Name "$serviceAppName Proxy" -SearchApplication $searchServiceApp
 
## Clone the default Topology (which is empty) and create a new one and then activate it ##
 
Write-Host "Configuring Search Component Topology..."
 
$appserv = Get-SPEnterpriseSearchServiceInstance -Identity $searchServerName
 
 
Get-SPEnterpriseSearchServiceInstance -Identity $appserv
 
 
$ssa = Get-SPEnterpriseSearchServiceApplication
 
 
$newTopology = New-SPEnterpriseSearchTopology -SearchApplication $ssa
 
 
New-SPEnterpriseSearchAdminComponent -SearchTopology $newTopology -SearchServiceInstance $appserv
 
New-SPEnterpriseSearchCrawlComponent -SearchTopology $newTopology -SearchServiceInstance $appserv
 
New-SPEnterpriseSearchContentProcessingComponent -SearchTopology $newTopology -SearchServiceInstance $appserv
 
New-SPEnterpriseSearchAnalyticsProcessingComponent -SearchTopology $newTopology -SearchServiceInstance $appserv
 
New-SPEnterpriseSearchQueryProcessingComponent -SearchTopology $newTopology -SearchServiceInstance $appserv
 
New-SPEnterpriseSearchIndexComponent -SearchTopology $newTopology -SearchServiceInstance $appserv
 
 
Set-SPEnterpriseSearchTopology -Identity $newTopology
 
 
 
Write-Host "Search Service Application installation Complete!"
 
##END SEARCH

#####################################################################################################################

######################

#Restoring a SSA

Add-PSSnapin "Microsoft.SharePoint.PowerShell" 
 
$SPSearchPoolAccount = Get-SPManagedAccount "PROD-SP_SearchSvc" 
New-SPServiceApplicationPool -Name "SharePoint Search Services" -Account $SPSearchPoolAccount  
 
$applicationPool = Get-SPServiceApplicationPool "SharePoint Search Services" 
 
# Gets the Search service instance and sets a variable to use in the next command 
$searchInst = Get-SPEnterpriseSearchServiceInstance -local 
 
Restore-SPEnterpriseSearchServiceApplication -Name 'SharePoint Search Service' -applicationpool $applicationPool -databasename 'Prod_Search' -databaseserver SharePointSQL -AdminSearchServiceInstance $searchInst  
 

$ssa = Get-SPEnterpriseSearchServiceApplication 
New-SPEnterpriseSearchServiceApplicationProxy -Name “SharePoint Search Service Proxy” -SearchApplication $ssa 
 
$ssap = Get-SPEnterpriseSearchServiceApplicationProxy 
Add-SPServiceApplicationProxyGroupMember -member $ssap -identity " "  
 
 
$newTopology = New-SPEnterpriseSearchTopology -SearchApplication $ssa 
$host1 = "Cicintapp2" 
$searchServiceInstance = Get-SPEnterpriseSearchServiceInstance | Where {$_.Server.Address -eq "$server"} 
New-SPEnterpriseSearchAdminComponent –SearchTopology $newTopology -SearchServiceInstance $host1 
New-SPEnterpriseSearchContentProcessingComponent –SearchTopology $newTopology -SearchServiceInstance $host1 
New-SPEnterpriseSearchAnalyticsProcessingComponent –SearchTopology $newTopology -SearchServiceInstance $host1 
New-SPEnterpriseSearchCrawlComponent –SearchTopology $newTopology -SearchServiceInstance $host1  
New-SPEnterpriseSearchIndexComponent –SearchTopology $newTopology -SearchServiceInstance $host1 
New-SPEnterpriseSearchQueryProcessingComponent –SearchTopology $newTopology -SearchServiceInstance $host1 
 
 
Set-SPEnterpriseSearchTopology -Identity $newTopology 
 
Write-Host "Search Done!" 

#####################################################################################################################

######################

#Nuking a SSA

get-spserviceapplication | Where-Object {$_.typename -like "search service*"} | Remove-spserviceapplication -RemoveData -confirm:$false
get-spserviceapplicationproxy | Where-Object {$_.typename -like "search service*"} | Remove-spserviceapplicationproxy -RemoveData -confirm:$false
 






